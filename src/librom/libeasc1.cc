#include "68040.hpp"
#include "chip/asc.hpp"
#include "inline.hpp"
#include "rom_common.hpp"
#include "rom_proto.hpp"
#include <expected>
#include <stdint.h>
#include <unordered_set>
void Set_TTR_t(Cpu::TTR_t &x, uint32_t v);
namespace LibROM {
extern const AddrMap *gAddrMap;
extern const UniversalInfo *gUnivInfo;
struct EascData {
    bool arpeggio;
    uint16_t wait[3];
    uint16_t value[4];
};
static const struct EascData EASC_DATA[] = {
    {false, {0, 0, 0}, {0x8000, 0xc000, 0x0000, 0xc080}},
    {true, {8, 8, 8}, {0x8000, 0xA145, 0xBFC9, 0x0000}},
    {true, {8, 8, 8}, {0x8000, 0x9838, 0xB505, 0xD745}},
    {true, {0xc, 6, 0xc}, {0x8000, 0x8FAD, 0x9838, 0x8000}},
    {true, {8, 8, 8}, {0xA145, 0xAADC, 0xA145, 0x879C}},
};

void play_sadmacBeep1() { play_sadmacBeep(1); }

void play_sadmacBeep4() { play_sadmacBeep(4); }

void play_sadmacBeep(int n) {
    const auto data = &EASC_DATA[n];
    asc->chA.IRQ_CTL = true;
    asc->chB.IRQ_CTL = true;
    asc->write(0x80A, 2);
    asc->write(0x803, 0x80);
    asc->volume = 0xE0;
    asc->write(0x801, 1);
    asc->chA.write_reg(8, 0);
    asc->chB.write_reg(8, 0);
    asc->chA.setSampleRate(0x812F);
    asc->chB.setSampleRate(0x812F);
    asc->chA.CD_XA_const[0] = 0;
    asc->chA.CD_XA_const[1] = 0x00;
    asc->chA.CD_XA_const[2] = 0x3C;
    asc->chA.CD_XA_const[3] = 0xCC;
    asc->chA.CD_XA_const[4] = 0x73;
    asc->chA.CD_XA_const[5] = 0xC9;
    asc->chA.CD_XA_const[6] = 0x62;
    asc->chB.CD_XA_const[0] = 0;
    asc->chB.CD_XA_const[1] = 0x00;
    asc->chB.CD_XA_const[2] = 0x3C;
    asc->chB.CD_XA_const[3] = 0xCC;
    asc->chB.CD_XA_const[4] = 0x73;
    asc->chB.CD_XA_const[5] = 0xC9;
    asc->chB.CD_XA_const[6] = 0x62;
    asc->chA.left_vol = 0x7f;
    asc->chA.right_vol = 0;
    asc->chB.left_vol = 0;
    asc->chB.right_vol = 0x7f;
    asc->chA.write_reg(8, 0x80);
    asc->chB.write_reg(8, 0x80);
    for(int i = 0; i < 128 * 4; ++i) {
        asc->chA.fifo_write(0x80);
        asc->chB.fifo_write(0x80);
    }
    uint16_t vals[4];
    vals[0] = data->value[0];
    if(!data->arpeggio) {
        vals[1] = data->value[1];
        vals[2] = data->value[2];
        vals[3] = data->value[3];
    } else {
        for(int i = 0; i < data->wait[0]; ++i) {
            play_easc_chime(0x4000, vals);
            wait_easc_fifo();
        }
        vals[1] = data->value[1];
        for(int i = 0; i < data->wait[1]; ++i) {
            play_easc_chime(0x4000, vals);
            wait_easc_fifo();
        }
        vals[2] = data->value[2];
        for(int i = 0; i < data->wait[2]; ++i) {
            play_easc_chime(0x4000, vals);
            wait_easc_fifo();
        }
        vals[3] = data->value[3];
    }
    for(int i = 0, v = 0x4000; i < 34; ++i, v -= 0x200) {
        play_easc_chime(v, vals);
        wait_easc_fifo();
    }
    while(asc->chA.fifo_full.load())
        asc->chA.fifo_full.wait(true);
    asc->write(0x801, 0);
    asc->volume = 0;
    /* stop chime */
    asc->chA.IRQ_CTL = false;
    asc->chB.IRQ_CTL = false;
}
void wait_easc_fifo() {
    while(!asc->chA.fifo_half.load())
        asc->chA.fifo_half.wait(false);
}

static const uint8_t easc_wave[] = {
    0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0, 0xFF, 0xF0, 0xE0,
    0xD0, 0xC0, 0xB0, 0xA0, 0x90, 0x80, 0x70, 0x60, 0x50, 0x40, 0x30,
    0x20, 0x10, 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80,
    0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0, 0xFF, 0xF0, 0xE0, 0xD0,
    0xC0, 0xB0, 0xA0, 0x90, 0x80, 0x70, 0x60, 0x50, 0x40, 0x30, 0x20,
    0x10, 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,

    0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0, 0xFF, 0xF0, 0xE0,
    0xD0, 0xC0, 0xB0, 0xA0, 0x90, 0x80, 0x70, 0x60, 0x50, 0x40, 0x30,
    0x20, 0x10, 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80,
    0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0, 0xFF, 0xF0, 0xE0, 0xD0,
    0xC0, 0xB0, 0xA0, 0x90, 0x80, 0x70, 0x60, 0x50, 0x40, 0x30, 0x20,
    0x10, 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,

    0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0, 0xFF, 0xF0, 0xE0,
    0xD0, 0xC0, 0xB0, 0xA0, 0x90, 0x80, 0x70, 0x60, 0x50, 0x40, 0x30,
    0x20, 0x10, 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80,
    0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0, 0xFF, 0xF0, 0xE0, 0xD0,
    0xC0, 0xB0, 0xA0, 0x90, 0x80, 0x70, 0x60, 0x50, 0x40, 0x30, 0x20,
    0x10, 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,

    0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0, 0xFF, 0xF0, 0xE0,
    0xD0, 0xC0, 0xB0, 0xA0, 0x90, 0x80, 0x70, 0x60, 0x50, 0x40, 0x30,
    0x20, 0x10, 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80,
    0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0, 0xFF, 0xF0, 0xE0, 0xD0,
    0xC0, 0xB0, 0xA0, 0x90, 0x80, 0x70, 0x60, 0x50, 0x40, 0x30, 0x20,
    0x10, 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70};

void play_easc_chime(uint16_t volume, const uint16_t vals[4]) {
    int32_t off[4] = {0, 0, 0, 0};
    do {
        int32_t v = 0;
        for(int i = 0; i < 4; ++i) {
            off[i] += vals[i] ? vals[i] : 0x10000;
            v += easc_wave[(off[i] >> 16) & 0xff];
        }
        v = (v - 512) * volume;
        int16_t hv = v >> 16;
        hv += 128;
        asc->chA.fifo_write((uint8_t)hv);
        asc->chB.fifo_write((uint8_t)hv);
    } while(!(asc->chA.fifo_full.exchange(false)));
}
} // namespace LibROM
